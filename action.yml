name: "ECR Build and Push"
description: "Builds and pushes Docker images to Amazon ECR"
author: "delivops"
branding:
  icon: "package"
  color: "blue"

inputs:
  image_name:
    description: "Name of the Docker image to build and push"
    required: true
  tag:
    description: "One or more tags to apply to the Docker image, separated by comma"
    required: true
  path:
    description: "Path to the Dockerfile context"
    required: false
    default: "."
  build_args:
    description: "Comma-separated list of build arguments to pass to the Docker build"
    required: false
    default: ""
  push:
    description: "Whether to push the Docker image to ECR"
    required: false
    default: "true"
  force_ecr_login:
    description: "Whether to force a new login to ECR"
    required: false
    default: "false"
  docker_layer_cache:
    description: "Whether to use docker caching"
    required: false
    default: "true"
  target:
    description: "Sets the target stage to build"
    required: false
    default: ""
  dockerfile_path:
    description: "Path to the Dockerfile"
    required: false
    default: "Dockerfile"
  platforms:
    description: "List of target platforms for build"
    required: false
    default: "linux/amd64"
  aws_account_id:
    description: "The AWS account ID"
    required: true
  aws_region:
    description: "The AWS region"
    required: true
  aws_role:
    description: "The AWS IAM role to assume"
    default: "github_services"
    required: false
  pull:
    description: "Always attempt to pull referenced images to avoid stale bases"
    required: false
    default: "true"
  no_cache:
    description: "Do not use cache when building the image"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Configure AWS credentials
      if: ${{ inputs.push == 'true' || inputs.force_ecr_login == 'true' }}
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: "arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.aws_role}}"
        aws-region: ${{ inputs.aws_region }}

    - name: Login to Amazon ECR
      if: ${{ inputs.push == 'true' || inputs.force_ecr_login == 'true' }}
      id: login_ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Prepare tags
      id: prepare_tags
      shell: bash
      run: |
        TAGS="${{ inputs.tag }}"
        REGISTRY="${{ steps.login_ecr.outputs.registry || 'local' }}"
        PREFIX="${REGISTRY}/${{ inputs.image_name }}:"
        IFS=',' read -ra ADDR <<< "$TAGS"
        IMAGES=""
        for i in "${ADDR[@]}"; do
          i_trimmed="$(echo "$i" | xargs)"
          if [ -z "$IMAGES" ]; then
            IMAGES="${PREFIX}${i_trimmed}"
          else
            IMAGES="${IMAGES},${PREFIX}${i_trimmed}"
          fi
        done
        echo "tags=$IMAGES" >> "$GITHUB_OUTPUT"

    - name: Ensure ECR repository exists
      if: ${{ inputs.push == 'true' }}
      shell: bash
      run: |
        set -e
        REPO="${{ inputs.image_name }}"
        aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$REPO" >/dev/null

    - name: Set up QEMU
      if: contains(inputs.platforms, 'arm64') || contains(inputs.platforms, '386') || contains(inputs.platforms, 'arm/') || contains(inputs.platforms, 'ppc64le') || contains(inputs.platforms, 's390x')
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build (and optionally push) Docker image
      uses: docker/build-push-action@v6.18.0
      with:
        context: ${{ inputs.path }}
        target: ${{ inputs.target }}
        push: ${{ inputs.push }}
        pull: ${{ inputs.pull }}
        no-cache: ${{ inputs.no_cache }}
        tags: ${{ steps.prepare_tags.outputs.tags }}
        build-args: ${{ inputs.build_args }}
        file: ${{ inputs.dockerfile_path }}
        platforms: ${{ inputs.platforms }}
        cache-from: ${{ inputs.docker_layer_cache == 'true' && 'type=gha' || '' }}
        cache-to: ${{ inputs.docker_layer_cache == 'true' && 'type=gha,mode=max' || '' }}
